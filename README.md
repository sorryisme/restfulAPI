# REST_API



## 1. REST 소개



### 역사

- 1990년 12월 WWW 비영리 소프트웨어 프로젝트를 팀 버너스 리가 고안
  - URI : 모든 웹 도큐먼트에 할당한 유일한 주소
  - HTTP : 인터넷을 통해 컴퓨터가 통신하기 위한 메세지 기반 언어
  - HTML : 정보 제공하는 도큐먼트를 표현하기 위한 하이퍼텍스트 마크업 언어
  - 최초의 웹서버 : http://info.cern.ch/





### 웹 아키텍처

- 로이 필등은 제약점을 모두 만족시켜서 웹이 지속적으로 확장할 수 이도록 프로젝트를 시작
- 웹의 구조적 스타일 : 제약점 6가지로 분류
  - 클라이언트/서버
  - 균일한 인터페이스
  - 계층시스템
  - 캐시
  - 상태없음
  - 주문형 코드



#### 클라이언트/서버

- 웹은 클라이언트/서버 기반 시스템으로 핵심사항은 관심사 분리
- 시스템 내에서 클라이언트 서버역할은 분명하게 나뉜다
- 일관된 인터페이스를 따른다는 전제하에 각자의 언어 및 기술을 통해 독립적으로 구현/배포 가능



#### 균일한 인터페이스

- 웹을 구헝하는 클라이언트, 서버, 네트워크 등 매체 간 인터페이스는 일관성에 기반

- 기존에 구축된 표준에서 벗어나면 웹 커뮤니케이션의 붕괴

- 웹 컴포넌트들은 네 가지 인터페이스 제약에 따라 서로 일관성 있께 상호운영

  - 리소스 식별

    - 웹 상에서 서로 구별되는 개념을 의미
- 표현을 위한 리소스 처리
  
  - 클라이언트는 리소스 표현을 처리
    - 같은 리소스라도 다른 클라이언트에서는 다른 방식으로 표현
      - 같은 데이터를 JSON 또는 HTML 또는 XML로 표현가능하다
    - 리소스와 상호작용하는 방법이지 리소스 그 자체는 아니라는 것
  - 자기 서술적 메세지

    - 리소스의 요청 상태는 클라이언트의 요청 메세지로 표현된다
  - 웹 페이지를 새로운 상태로 업데이트하도록 제안하는 표현을 전달할 때 요청 메세지 사용
      - 클라이언트의 요청을 받아들일 것인가 여부는 서버에 달려있음
    - 자기-서술적 메시지는 메타 데이터를 포함
  - 애플리케이션 상태 엔진으로서의 하이퍼미디어(* HATEOAS)
  - 리소스의 상태 표현은 관련 리소스 링크 포함

#### 계층시스템

-  프록시 또는 게이트웨이 같은 네트워크 기반의 중간 매체를 사용할 수 있게한다
- 일관된 인터페이스를 사용하면 중간매체가 없는것처럼 배치할 수 있다.

#### 캐시

- 웹서버가 응답데이터마다 캐시 여부를 선언
- 지연을 감소시키고 안정성 향상
- 웹 서버단, 콘텐츠 전송망(CDN), 클라이언트 내에서도 가능

#### 상태없음

- 웹 서버가 클라이언트 상태를 관리할 필요가 없다
- 각 클라이언트는 웹서버와 상호작용하는 관련 상황 정보를 직접관리

#### 주문형 코드

- 스크립트나 플러그인 같은 실행가능한 프로그램을 일시적으로 클라이언트에 전송하여 실행할 수 있도록한다
- 예로 자바 애플릿, 자바스크립트, 플래시 같은 웹 브라우저 기반 기술



### 웹표준

- 필딩은 HTTP/1.1 스펙 작성, 웹 지속적 확장에 기여
- REST : 웹의 구조적 스타일 (Representational State Transfer : 표현상태전이)라는 논문을 작성



### REST API

- 보통 API는 데이터와 기능의 집합을 제공
- 클라이언트의 요청을 직접적으로 듣고 응답한다
- REST 구조 스타일에 적합한 Web API를 REST API라고 한다



### REST API 설계

- URI 경로 세그먼트는 언제 복수로 써야하는가?
- 리소스 상태를 업데이트 하려면 어떤 메서드를 사용해야하는가?
- CRUD가 아닌 연산을 어떻게 URL에 매핑하는가?
- 특정 시나리오에 가장 적합한 HTTP 응답은 무엇인가?
- 리소스 상태 표현의 버전은 어떻게 관리할 수 있는가?

- JSON에 포함된 하이퍼링크는 어떻게 구조화하는가?



#### WRML 

- REST API 설계와 구현에 도움을 주는 프레임워크



## 2. URL 식별자 설계



### URI 

- REST API는 리소스를 나타낼 때 URI를 사용
- URI는 불투명한 식별자



### URI 형태

- 규칙
  - 슬래시 구분자는 계층관계를 나타내는데 사용
  - 마지막 문자로 슬래시를 사용하지 않는다
  - 하이픈(-)은 URI 가독성을 높이는데 사용
  - 밑줄(_)은 URI에 사용하지 않는다
  - URI 경로에는 소문자가 적합
  - 파일확장자는 URI에 포함하지 않는다



### URI 권한 설계

- 규칙 
  - API에 있어서 서브 도메인은 일관성 있께 사용
    - 1차 서브 도메인 예: soccer.restapi.org
    - 권고 : http://api.soccer.restApi.org
  - 클라이언트 개발자 포탈  서브 도메인 이름은 일관성 있께 작성
    - developer.soccer.restapi.org



#### URI 경로디자인

- 규칙

  - 도큐먼트 이름은 단수 명사

  - 컬렉션 이름으로는 복수명사 사용

  - 스토어 이름은 복수 명사

  - 컨트롤러 이름으로는 동사나 동사구

  - 변하는 부분은 유일한 값으로 대체 ex: api.soccer.restapi.org/leagues/{leagueId}

  - CRUD 기능을 나타내는 것은 URI에 나타내지 않는다

    - URI는 리소스만 식별하는데 사용해야한다
    - DELETE /users/1234

    

#### URI QUERY 디자인

- 쿼리 구성요소는 검색이나 필터링 같은 추가적인 상호작용 능력을 제공
- REST API 클라이언트에 반드시 필요한 것이 아니다
- 규칙
  - URI 쿼리 부분은 컬렉션이나 스토어를 필터링 할 수 있다.
    - GET /users : 모든 사용자 리스트
    - GEt /user?role=admin : role이 admin 사용자 리스트
  - URI 쿼리는 컬렉션이나 스토어의 결과를 페이지로 구분하여 나타내는데 사용
    - pageSzie, pageStartIndex 같은 값으로 페이지화 한다



## 3. HTTP를 이용한 인터렉션 설계



### HTTP 1.1

- REST API는 요청 메서드, 응답 코드, 메시지 헤더 등 HTTP 1.1 버전에 모든 측면을 수용



### 요청 메서드

- 클라이언트는 상호작용하려는 메서드를 Request-Line 부분에 명시
  - GET 리소스 상태 표현
  - HEAD 리소스 상태에 대한 메타 데이터
  - PUT 리소스를 스토어에 추가 갱신
  - DELTE 부모에서 리소스를 제거
  - POST 새로운 리소스를 만들거나 컨트롤러 실행
- 규칙
  - GET 메서드나 POST 메서드를 사용해서 다른 요청 메서드를 처리해선 안된다.
  - GET 메서드는 리소스 상태를 표현을 얻는데 사용
    - GET 요청을 반복해도 문제가 없어야함
    - 캐시된 내용을 제공할 수 있어야한다
  - 응답 헤더를 가져올 때는 반드시 HEAD 메서드를 사용해야한다
  - PUT 메서드는 리소르를 삽입하거나 저장된 리소스를 갱신하는데 사용
  - PUT 메서드는 변경 가능한 리소스를 갱신하는데 사용해야한다
  - POST 메서드는 컬렉션에 새로운 리소스를 만드는데 사용해야한다
  - POST 메서드는 컨트롤러를 실행하는데 사용해야한다
    - 클라이언트는 POST 메서드를 사용해 기능 지향적인 컨트롤러 리소스를 동작시킨다.
    - POST 요청 메서드는 안전하지도 않고 사용할  때마다 리소스 상태값이 바뀔 수 있다.
    - 결과를 예측할 수도 부작용 없이 반복적으로 사용하는 것을 보장할 수 없다
    - POST를 두번 제출하면 신용카드가 두번 결제 될 수도 있다.
  - DELETE 메서드는 그 부모에서 리소스를 삭제하는데 사용해야한다
    - 컬렉션이나 스토어인 부모에서 리소스를 완전히 제거한다
    - 오버로드 되거나 확장될 수 없다
  - OPTIONS 메서드는 리소스의 사용 가능한 인터렉션 기술한 메타데이터를 가져오는데 사용
    - Allow 헤더에 포함된 리소스 메타 데이터를 가져온다
      - Allow : GET, PUT, DELETE



### 응답 상태 코드

- 응답 상태코드 범주 
  - 1XX : 정보 
  - 2XX : 성공
  - 3XX : 재전송
  - 4XX : 클라이언트 오류
  - 5XX : 서버오류



#### 상세 상태코드

- 200 : 일반적인 성공 (OK)
  - 클라이언트가 요청한 액션이 성공적으로 수행됨을 표현
  - 204와 달리 200응답은 응답 바디가 포함
- 200 : 응답 바디에 에러전송에 사용해서는 안됨 (OK)
- 201 : Created는 성공적으로 리소스를 생성했을 때 사용 (Created)
- 202 : 비동기 처리가 성공적으로 시작되었음을 알릴 때 사용 (Accepted)
  - 비동기 처리가 시작되었음을 나타내지만 처리되까지 문제될 수 있음
- 204 : 응답 바디에 의도적으로 아무것도 포함하지 않음(No Conents)
- 301 : 리소스를 이동시켰을 때 사용 (Moved Permanently)
  - REST API 리소스 모델이 재설 계되었거나 URI가 새로 할당 되었을 때
  - Location 헤더에 새로운 URI를 기술
- 302 : Found를 사용하지 않는다
  - 302 대신 303(See Other), 307(Temporary Redirect)를 사용할 것
- 303 : 다른 URI를 참조하라고 알려줄 때 사용한다(See Other)
- 304 : 대역폭을 절약할 때 사용 (Not Modified)
  - 응답 바디에 아무것도 없어야한다
  - 리소스에 대한 상태정보가 있지만 클라이언트에 이미 상태 최신 버전이 있다는 걸 의미
- 307 : 클라이언트가 다른 URI로 요청을 다시 보내게할 때 사용(Temporary Redirect)
- 400 : 일반적인 요청 실패 (Bad Request)
- 401 : 클라이언트 인증 문제(Unauthorized)
- 403 : 인증 상태와 상관없이 액세스 금지에 사용(Forbidden)
  - 요청은 정상이지만 요청에 응하지 않을 때
- 404 : 요청 URI에 해당하는 리소스가 없을 때 사용 (Not Found)
- 405 : HTTP 메서드가 지원되지 않을 때 (Method Not Allowed)
- 406 : 요청된 리소스 미디어 타입을 제공하지 못할 때 (Not Acceptable)
  - Accept 요청 헤더에 있는 미디어 타입 중 해당하는 것을 만들지 못할 때
- 409 : 리소스 상태에 위반되는 행위를 했을 때 (Confilict)
  - 리소스가 불가능 또는 모순된 상태
  - 비어있지 않은 스토어 리소스 삭제 요청 시
- 412 : 조건부 연산을 지원할 때 사용 (Precondition failed)
  - 특정한 조건이 만족될 때만 요청이 수행되도록 할 때
  - 조건이 만족되지 않았을 때에는 다음과 같은 응답코드
- 415 : 요청의 페이로드에 있는 미디어 타입이 처리되지 못했을 때(Unsupported Media Type)
  - 요청 헤더의 Content-Type에 기술한 클라이언트가 제공한 미디어 타입을 처리하지 못했을 때 발생
- 500 : API가 잘못 작동할 때 (Internal Server Error)
  - 예외 사항이 발생했을 때 주로 응답코드는 500발생



#### 용어 정리

- Request-Line 
  - Method
  - URI
  - HttpVersion
- Status-Line 
  - HttpVersion
  - Status Code
  - Reasone-Phrase



## 4. 메타데이터 디자인



### HTTP 헤더

- 요청메세지와 응답 메세지에 포함된 헤더를 통해 여러 형태의 메타데이터가 전송된다
- 일부는 요청된 리소스 정보를 제공한다



#### Content-Type 사용

- 요청이나 응답 메세지 바디에 있는 데이터 타입을 나타낸다
- 이 헤더 값을 참조해 메세지 바디에 있는 바이트열 처리방법을 결정



#### Content-Length 사용

- 바이트 단위로 바디의 크기를 나타낸다
  - 바이트 크기를 올바르게 읽었는지 알 수 있다.
  - HEAD 요청을 사용하여 데이터 다운받지 않고 바디가 얼마나 큰지 알 수 있음



#### Last-Modified는 응답에 사용

- 응답 메세지에만 사용해야한다
- 리소스의 표현 상태 값이 바뀐 마지막 시간을 나타낸다
- 클라이언트와 캐시 중간자는 이 헤더 값을 이용하여 리소스 상태 표현의 갱신여부를 결정



#### ETag는 응답에 사용해야한다

- 표현 상태의 특정 버전을 나타낸다



#### 스토어는 조건부 PUT 요청을 지원해야한다

- 스토어 리소스는 PUT 메서드를 사용하여 리소스를 새로 추가하거나 갱신할 수 있다.
- 클라이언트의 IF-Unmodified-SInce, If-Match를 통해 의도를 알 수 있음
  - 리소스의 상태 표현이 타임 스탬프 시간 이후 바뀌지 않았을 경우에만 동작하도록 요구
  - If-Match 헤더 값은 클라이언트가 받은 이전 응답의 HTag 헤더 값
- 예시 
  - 클라이언트 #1은 URI로 요청
  - REST API는 처음 보는 데이터이기에 새로 생성하고 201 Response
  - client#2는 같은 URI로 데이터 요청
  - 이 요청이 새로 생성인지 갱신인지 알 수 없음
    - 409 Conflict 에러 발생
  - If-Matched 헤더를 포함하여 재요청 할 수 있음



#### Location은 새로 생성된 리소스의 URI 나타냄

- 컬렉션이나 스토어에 성공적으로 리소스를 생성했다는 응답



#### Chache-Control, Expires, Date 응답헤더는 캐시 사용을 권장하는데 사용

- 캐싱은 클라이언트 대기시간을 줄이고, 신뢰성을 향상, API 서버의 부하를 감소 
- 상태 표현을 제공할 때 Chache-Control 헤더와 초 단위 max-age 값 갱신주기를 제공



#### Chache-Control, Expire, Pragma 응답 헤더는 캐시 사용을 중지하는 데 사용

- REST PAI 응답을 캐시에 저장하지 않도록 하려면, Cache-Control 헤더 값을 no-cache나 no-store로 설정
- HTTP 1.0과 상호 운영을 고려한다면 "Pragma: no-cache"와 Expires: 0 헤더에 추가



#### 캐시 기능은 사용

- no-cache 지시자는 캐시 응답을 제공되는 것을 막는다

- 꼭 필요한 경우 아니면 캐시를 사용하지 않는다



#### 만기 캐싱 헤더는 200("OK") 응답에 사용해야 한다

- 만기 캐싱 헤더는 GET 메서드와 HEAD 메서드에 요청에 대한 응답으로 설정
- 실제로 POS 메서드는 캐시에 저장 가능하지만 대부분의 캐시는 캐시에 저장하기 불가능한 것으로 취급



#### 만기 캐싱 헤더는 3xx와 4xx 응답에 선택적으로 사용할 수 있음

- 3xx와 4xx에 대한 캐싱 헤더를 추가하는 것을 고려
- 네거티브 캐싱은 리다이렉트 횟수와 REST API에 따른 부하를 감소



## 4.2 미디어 타입

- 데이터 형태를 식별하기 위해 Content-Type 헤더 값을 미디어 타입이라고 함
- type 값 : application, audio, image, message, model, multipart, text, video
- type/subtype 다음에 attribute=value 같은 형태로 파라미터로 쓸 수 있음
  - Content-type: text/html;charset=UTF-8



### 등록된 미디어 타입

- text/plain : 마크업이 없는 평문 포맷
- text/html : html로 포맷된 컨텐츠
- image/jpeg : 표준화한 이미지 압축방식
- application/xml : xml로 구조화된 컨텐츠
- aplication/atom + xml : xml 기반의 리스트로 포맷팅한 Atom 사용 컨텐츠
- application/javascript : 자바스크립트 
- application/json : 데이터 교환에 사용되는 JSON 포맷



### 미디어 타입의 설계



#### 어플리케이션 고유의 미디어타입을 사용

- 응답의 Content-type 헤더 필드는 바디에 JSON 형태로 표현된 플레이어 도큐먼트가 있다는 것을 분명히 나타내야한다

#### 리소스의 표현이 여러가지 가능할 경우 미디어 타입 협상을 지원해야한다

- 클라이언트에서 원하는 미디어 타입을 Accept 헤더에 추가하여 협상할 수 있어야한다

#### query 변수를 사용한 미디어 타입 선택을 지원할 수 있다.

- 쿼리 파라미터에 accept를 통해 미디어 타입을 선택할 수 있다.



### 표현디자인

#### 5.1 메세지 바디 포맷

- 리소스의 상태를 응답 메세지의 바디를 이용해 전달
- 텍스트 기반의 포맷을 이용하여 리소스 상태를 표현
- 현재 가장 많이 사용되는 텍스트 포맷은 XML과 JSON
  - XML은 꺽쇠 괄호 태그를 이용
  - JSON은 중괄호를 사용



#### 규칙 : JSON 리소스 표현을 지원

- 특정 리소스 타입에 대한 표준 포맷이 없을 경우 JSON 포맷 사용



#### 규칙 : JSON은 문법에 잘 맞아야한다

- 키-값 쌍으로 구성, 순서에 무관한 집합

- 키 값을 문자열로 정의하며 항상 큰 따옴표 안에 넣는다

- 다음 예제는 모든 키 값을 따음표 안에 넣은 JSON

  ```javascript
  {
  	"firstName" : "Osvaldo",
  	"lastName" : "Alonso",
  	"firstNamePronunciation" : "ahs-VAHL_doe",
  	"number" : 6, //JSON은 숫자를 지원
  	"birthDate" : "1985-11-11" //시간과 날짜를 지원하지 않아 문자열로 표현
  
  }
  ```

  - var.fooBar  : 상대적으로 깔끔한 표기법
  - var["foo-bar"] : 덜 우아한 자바스크립트 표기법



#### 규칙 : XML과 다른 표현 형식은 선택적으로 지원할 수 있다.

- XML과 HTML 등의 리소스를 표현하기 위해 선택적으로 대체 포맷을 사용하여 다른 언어를 지원할 수 있음



#### 규칙 : 추가 봉투는 없어야한다

- HTTP가 제공한 메세지 봉투를 이용해야 함



### 5.2 하이퍼미디어 표현

- REST API도 HTML 기반 처럼 하이퍼미디어를 채택하여 표현
- 일관된 링크 구조를 사용하여 프로그램 적으로 탐색



#### 규칙 : 링크는 일관성 된 형태로 나타내야한다

- 링크는 리소스 상태표현 안에 필드와 함께 포함되어야한다

- 참고

  ```
  application/wrml:
  	format="http://apoi.formats.wrml.rog/application/json",
  	schema="http://api.schemas.wrml.org/common/Link"
  ```

  - application/wrml: WRML 미디어 타입을 나타냄 
  - schema: ... 현재 Link 스키마의 버전 표시

- JSON으로 포맷팅하면 다음같은 폼이 된다

  ```json
  {
  	"href" : Text <constrained by URI or URI Template syntax> ,
      "rel" : Text <constrained by URI syntax> ,
      "requestTypes" : Array <constrained to contain media type text elements> ,
      "responeTypes" : Array <constrained top contain media type text elements>,
      "title" : Text
  }
  ```

  - 필수 요소인  href 값은 링크의 타깃 리소스를 나타냄
    
    - URI나 URI 템플릿 사용가능
  - rel 같은 링크 관계를 기술하는 도큐먼트를 나타냄
  - 연결된 리소스의 허용된 요청 바디 미디어 타입이 나열
    
    - 클라이언트는 연결된 리소스에 요청하기전에 확인하는 것이 좋음
  - responseTypes 값은 사용가능한 응답 바디 미디어 타입이 나열
    
    - Accept 헤더에 있는 미디어타입에 우선순위를 매길 때 이 값을 참조
    
    

#### 규칙 : 링크관계를 표현할 때에는 일관된 형태를 사용

> 예시

````json
{
	"firstName" : "Osvaldo",
	"lastName" : "Alonso", 
	"links" : {
	
		"self" :{
			"href" : "http://api.soccer.restapi.org/players/2113",
			"rel" : "http://api.relations.wrml.org/common/self"
		},
		"parent" : {
			"href" : "http://api.soccer.restapi.org/players",
			"rel" : "http://api.relations.wrml.org/common/parent"
		},
		"team" : {
			"href" : "http://api.so...중략"
		}
	} 
}
````

- links 항목은 상위레벨 키-값
- links 객체의 각 항목은 일관된 링크 구조
- 클라이언트에서 리소스를 스토어에 추가할 수 있도록 REST API는 링크의 href 값으로 path 기반 변수를 포함한 URI 템플릿을 사용할 수 있음



#### 규칙: 응답 메세지 바디 표현에 셀프 링크를 포함해야한다

- 리소스의 표현을 포함한 응답 메세지 바디는 self 라는 이름의 링크를 포함



#### 규칙 : 진입 API URI 수를 최소화

- API Docroot에서 사람이 읽을 수 있는 형태의 문서를 제공하는 것이 REST API이다
- 다른 모든 리소스를 프로그램적으로 사용할 수 있게하는 링크를 제공



#### 규칙 : 리소스 상태에 따라 가능한 액션을 표현하기 위해서 링크 사용

- Web API는 여러 리소스에 수행할 수 있는 액션을 알리기 위해 문서 제공
- 이러한 문서는 URI 템플릿을 나열, 호출 후 예상되는 결과값 설명
- HATEOAS 제한 조건은 클리이언트의 모든 요청에 대해 API는 상태에 민감한 링크를 포함하는 리소스 표현으로 응답



### 미디어 타입 표현

- Content-Type과 Accept HTTP 헤더에 있는 메타 데이터 의미를 강화할 수 있다



#### 규칙 : 미디어 타입 format은 일관성 있는 폼을 사용해야한다.

- application/wrml 미디어 타입은 포맷을 기술하는 도큐먼트를 나타내는 URI 값
